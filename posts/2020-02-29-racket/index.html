<!doctype html><html lang=en-us><head><meta http-equiv=x-clacks-overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://damotek.github.io/www/images/favicon.png><title>Racket notes | Hugo ʕ•ᴥ•ʔ Bear Blog</title><meta name=title content="Racket notes"><meta name=description content="Basic #lang racket (provide (all-defined-out)) ;this is a comment (define s &#34;hello&#34;) (define x 3) (define y (+ x 2)) (define cube1 (lambda (x) (* x (* x x)))) (define cube2 (lambda (x) (* x x x))) (define (cube3 x) (* x x x)) (define (pow1 x y) (if (=y 0) 1 (* x (pow1 x (- y 1))))) ; currying (define pow2 (lambda (x) (lambda (y) (pow1 x y)))) List Empty list: null () doesn&#34;t work for null but '() does build a list: (list e1 ."><meta name=keywords content="racket,"><meta property="og:title" content="Racket notes"><meta property="og:description" content="Basic #lang racket (provide (all-defined-out)) ;this is a comment (define s &#34;hello&#34;) (define x 3) (define y (+ x 2)) (define cube1 (lambda (x) (* x (* x x)))) (define cube2 (lambda (x) (* x x x))) (define (cube3 x) (* x x x)) (define (pow1 x y) (if (=y 0) 1 (* x (pow1 x (- y 1))))) ; currying (define pow2 (lambda (x) (lambda (y) (pow1 x y)))) List Empty list: null () doesn&#34;t work for null but '() does build a list: (list e1 ."><meta property="og:type" content="article"><meta property="og:url" content="https://damotek.github.io/www/posts/2020-02-29-racket/"><meta property="og:image" content="https://damotek.github.io/www/images/share.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-02-29T09:00:00+00:00"><meta property="article:modified_time" content="2020-02-29T09:00:00+00:00"><meta property="og:site_name" content="Hugo ʕ•ᴥ•ʔ Bear"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://damotek.github.io/www/images/share.png"><meta name=twitter:title content="Racket notes"><meta name=twitter:description content="Basic #lang racket (provide (all-defined-out)) ;this is a comment (define s &#34;hello&#34;) (define x 3) (define y (+ x 2)) (define cube1 (lambda (x) (* x (* x x)))) (define cube2 (lambda (x) (* x x x))) (define (cube3 x) (* x x x)) (define (pow1 x y) (if (=y 0) 1 (* x (pow1 x (- y 1))))) ; currying (define pow2 (lambda (x) (lambda (y) (pow1 x y)))) List Empty list: null () doesn&#34;t work for null but '() does build a list: (list e1 ."><meta itemprop=name content="Racket notes"><meta itemprop=description content="Basic #lang racket (provide (all-defined-out)) ;this is a comment (define s &#34;hello&#34;) (define x 3) (define y (+ x 2)) (define cube1 (lambda (x) (* x (* x x)))) (define cube2 (lambda (x) (* x x x))) (define (cube3 x) (* x x x)) (define (pow1 x y) (if (=y 0) 1 (* x (pow1 x (- y 1))))) ; currying (define pow2 (lambda (x) (lambda (y) (pow1 x y)))) List Empty list: null () doesn&#34;t work for null but '() does build a list: (list e1 ."><meta itemprop=datePublished content="2020-02-29T09:00:00+00:00"><meta itemprop=dateModified content="2020-02-29T09:00:00+00:00"><meta itemprop=wordCount content="794"><meta itemprop=image content="https://damotek.github.io/www/images/share.png"><meta itemprop=keywords content="racket,"><meta name=referrer content="no-referrer-when-downgrade"><style>body{font-family:Verdana,sans-serif;margin:auto;padding:20px;max-width:720px;text-align:left;background-color:#fff;word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:#444}h1,h2,h3,h4,h5,h6,strong,b{color:#222}a{color:#3273dc}.title{text-decoration:none;border:0}.title span{font-weight:400}nav a{margin-right:10px}textarea{width:100%;font-size:16px}input{font-size:16px}content{line-height:1.6}table{width:100%}img{max-width:100%}code{padding:2px 5px;background-color:#f2f2f2}pre code{color:#222;display:block;padding:20px;white-space:pre-wrap;font-size:14px}div.highlight pre{background-color:initial;color:initial}div.highlight code{background-color:unset;color:unset}blockquote{border-left:1px solid #999;color:#222;padding-left:20px;font-style:italic}footer{padding:25px;text-align:center}.helptext{color:#777;font-size:small}.errorlist{color:#eba613;font-size:small}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:#8b6fcb}@media(prefers-color-scheme:dark){body{background-color:#333;color:#ddd}h1,h2,h3,h4,h5,h6,strong,b{color:#eee}a{color:#8cc2dd}code{background-color:#777}pre code{color:#ddd}blockquote{color:#ccc}textarea,input{background-color:#252525;color:#ddd}.helptext{color:#aaa}}</style></head><body><header><a href=/ class=title><h2>Hugo ʕ•ᴥ•ʔ Bear Blog</h2></a><nav><a href=/>Home</a>
<a href=/www/bear/>Bear</a>
<a href=/www/hugo/>Hugo</a>
<a href=/blog>Blog</a></nav></header><main><content><h2 id=basic>Basic</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#f92672>#lang </span>racket
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>provide</span> (<span style=color:#66d9ef>all-defined-out</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>;this is a comment</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> s <span style=color:#e6db74>&#34;hello&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> x <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> y (+ x <span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> cube1
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>lambda</span> (x)
</span></span><span style=display:flex><span>    (* x (* x x))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> cube2
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>lambda</span> (x)
</span></span><span style=display:flex><span>    (* x x x)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (cube3 x)
</span></span><span style=display:flex><span>  (* x x x))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (pow1 x y)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>if</span> (=y <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>      (* x (pow1 x (- y <span style=color:#ae81ff>1</span>)))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; currying</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> pow2
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>lambda</span> (x)
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>lambda</span> (y)
</span></span><span style=display:flex><span>      (pow1 x y))))
</span></span></code></pre></div><h3 id=list>List</h3><ul><li>Empty list: <code>null</code><ul><li><code>()</code> doesn"t work for <code>null</code> but <code>'()</code> does</li></ul></li><li>build a list: <code>(list e1 ... en)</code></li><li>Constructor: <code>cons</code></li><li>Access head of list: <code>car</code></li><li>Access tail of list: <code>cdr</code></li><li>Check for empty: <code>null?</code></li></ul><h3 id=syntax>Syntax</h3><p>A term is either:</p><ul><li>An atom like <code>#t, #f, 34, "hi", null, 4.0, x,...</code></li><li>A special form like <code>define, lambda, if</code></li><li>A sequence of terms in parentheses: <code>(t1 t2 t3)</code></li><li>Can use <code>[</code> anything you use <code>(</code></li></ul><p>Remember parentheses matters! For example:
<code>(e)</code> means call e with 0 argument.</p><h3 id=dynamic-typing>Dynamic typing</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span>(<span style=color:#66d9ef>define</span> lst (list <span style=color:#66d9ef>#t</span> <span style=color:#e6db74>&#34;hi&#34;</span> <span style=color:#ae81ff>1</span> (list <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span>)))
</span></span></code></pre></div><h3 id=cond>Cond</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (sum3 xs)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>cond</span> [(null? xs) <span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        [(number? (car xs)) (+ (car xs) (sum3 (cdr xs)))]
</span></span><span style=display:flex><span>        [<span style=color:#66d9ef>#t</span> <span style=color:#ae81ff>0</span>]))
</span></span></code></pre></div><h3 id=what-is-true>What is true?</h3><p>Anything that is not <code>#f</code> is true <code>#t</code>.</p><h3 id=local-bindings>Local bindings</h3><h4 id=letletletrec>let/let*/letrec</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span>(<span style=color:#66d9ef>let</span> ([x1 e1]
</span></span><span style=display:flex><span>      [x2 e2]
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>...</span>
</span></span><span style=display:flex><span>      [xn en])
</span></span><span style=display:flex><span>  e)
</span></span></code></pre></div><p>Racket uses the environment <strong>before</strong> the let-expression to evaluate <code>e1 e2 ... en</code>, which means if <code>en</code> uses <code>x1</code>, <code>x2</code>, that would mean some outer variables of the same name. Instead, the expressions in <code>let*</code> are evaluated in the environment produced from the previous bindings (later ones shadow) .</p><p>The expressions in <code>letrec</code> are evaluated in the environment that includes all th bindings. It is needed for mutual recursion.</p><h3 id=set>set!</h3><p>Racket has assignment statements:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span>(<span style=color:#66d9ef>set!</span> x e)
</span></span></code></pre></div><p>Once you have side-effects, sequences are useful:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span>(<span style=color:#66d9ef>begin</span> e1 e2 e3)
</span></span></code></pre></div><h3 id=consmcons>cons/mcons</h3><p><code>cons</code> produces pairs or lists. (Actually lists are just extented pairs)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span>(<span style=color:#66d9ef>define</span> pr (cons <span style=color:#ae81ff>1</span> (cons <span style=color:#66d9ef>#t</span> <span style=color:#e6db74>&#34;hi&#34;</span>))) <span style=color:#75715e>; is a pair</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> lst (cons <span style=color:#ae81ff>1</span> (cons <span style=color:#66d9ef>#t</span> (cons <span style=color:#e6db74>&#34;hi&#34;</span> null)))) <span style=color:#75715e>; is a list</span>
</span></span></code></pre></div><p><code>mcons</code> is another way to make pairs which allows you to change the value inside piars:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span>(<span style=color:#66d9ef>define</span> mpr (mcons <span style=color:#ae81ff>1</span> (mcons <span style=color:#66d9ef>#t</span> <span style=color:#e6db74>&#34;hi&#34;</span>)))
</span></span><span style=display:flex><span>(mcar mpr) <span style=color:#75715e>; 1</span>
</span></span><span style=display:flex><span>(mcdr mpr) <span style=color:#75715e>; (mcons (#t &#34;hi&#34;))</span>
</span></span><span style=display:flex><span>(set-mcdr! mpr <span style=color:#ae81ff>47</span>) <span style=color:#75715e>; mpr becomes (mcons 1 47)</span>
</span></span></code></pre></div><p>Related form:</p><ul><li><code>mcons</code></li><li><code>mcar</code></li><li><code>mcdr</code></li><li><code>mpair?</code></li><li><code>set-mcar!</code></li><li><code>set-mcdr!</code></li></ul><h2 id=delayed-evaluation-and-thunk>Delayed Evaluation and Thunk</h2><p>In most programming languages, given <code>e1 e2 ... en</code>, the function arguments <code>e2, ..., en</code> are evaluated once before the function body is executed.
So if we define a function like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rkt data-lang=rkt><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (my-if-bad x y z) (<span style=color:#66d9ef>if</span> x y z))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (factorial-wrong x)
</span></span><span style=display:flex><span>  (my-if-bad (= x <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>             <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>             (* x (factorial-wrong (- x <span style=color:#ae81ff>1</span>)))))
</span></span></code></pre></div><p>if we use <code>if</code> instead of <code>my-if-bad</code>, <code>factorial-wrong</code> acts just like we want. But with <code>my-if-bad</code>, the function never stops because the two branches evaluate at the same time.</p><p>Thanks to lambda, we can delay the evaluation, using the fact that function bodies are not evaluated until the function gets called.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rkt data-lang=rkt><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (my-if x y z) (<span style=color:#66d9ef>if</span> x (y) (z)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (factorial x)
</span></span><span style=display:flex><span>  (my-if (= x <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>         (<span style=color:#66d9ef>lambda</span> () <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>         (<span style=color:#66d9ef>lambda</span> () (* x (factorial (- x <span style=color:#ae81ff>1</span>))))))
</span></span></code></pre></div><p>The general idiom of using a zero-argument function to delay evaluation is also called a <strong>thunk</strong> (or, thunk the argument).</p><p>By the way,</p><h2 id=lazy-evaluationcall-by-needpromises>Lazy-evaluation/Call-by-need/Promises</h2><h2 id=streams>Streams</h2><p>A stream is an infinite sequence of values.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span><span style=color:#f92672>#lang </span>racket
</span></span><span style=display:flex><span><span style=color:#75715e>; 1 1 1 1 ...</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> ones (<span style=color:#66d9ef>lambda</span> () (cons <span style=color:#ae81ff>1</span> ones)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; 1 2 3 4 ...</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> nats
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>letrec</span> ([f (<span style=color:#66d9ef>lambda</span> (x) (cons x (<span style=color:#66d9ef>lambda</span> () (f (+ x <span style=color:#ae81ff>1</span>)))))])
</span></span><span style=display:flex><span>     (<span style=color:#66d9ef>lambda</span> () (f <span style=color:#ae81ff>1</span>))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; 2 4 6 8 ...</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> power-of-two
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>letrec</span> ([f (<span style=color:#66d9ef>lambda</span> (x) (cons x (<span style=color:#66d9ef>lambda</span> () (f (* x <span style=color:#ae81ff>2</span>)))))])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>lambda</span> () (f <span style=color:#ae81ff>2</span>))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; higher-order maker</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define</span> (stream-maker fn arg)
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>letrec</span> ([f (<span style=color:#66d9ef>lambda</span> (x) (cons x (<span style=color:#66d9ef>lambda</span> () (f (fn x arg)))))])
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>lambda</span> () (f arg))))
</span></span></code></pre></div><h2 id=memoization-not-memorization>Memoization (Not Memorization)</h2><p>Memoization is another idiom related to lazy evaluation that does not actually use thunks. To implement memoization we do use mutation: Whenever the function is called with an argument we have not seen before, we compute the answer and then add the result to the table.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span>(<span style=color:#66d9ef>define</span> fibonacci
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>letrec</span>([memo null]
</span></span><span style=display:flex><span>          [f (<span style=color:#66d9ef>lambda</span> (x)
</span></span><span style=display:flex><span>               (<span style=color:#66d9ef>let</span> ([ans (assoc x memo)])
</span></span><span style=display:flex><span>                 (<span style=color:#66d9ef>if</span> ans
</span></span><span style=display:flex><span>                     (cdr ans)
</span></span><span style=display:flex><span>                     (<span style=color:#66d9ef>let</span> ([new-ans (<span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>or</span> (= x <span style=color:#ae81ff>1</span>) (= x <span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>                                        <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                                        (+ (f (- x <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>                                           (f (- x <span style=color:#ae81ff>2</span>))))])
</span></span><span style=display:flex><span>                       (<span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>                         (<span style=color:#66d9ef>set!</span> memo (cons (cons x new-ans) memo))
</span></span><span style=display:flex><span>                         new-ans)))))])
</span></span><span style=display:flex><span>    f))
</span></span></code></pre></div><h2 id=macros>Macros</h2><p>Think about these things about macros and how Racket handles them better than other macro systems(notably C/C++)</p><ul><li>Tokenization</li><li>Parenthesization</li><li>Scope</li></ul><h3 id=syntax-1>Syntax</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span>(<span style=color:#66d9ef>define-syntax</span> myif
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>syntax-rules</span> (then <span style=color:#66d9ef>else</span>)
</span></span><span style=display:flex><span>    [(my-if e1 then e2 <span style=color:#66d9ef>else</span> e3)
</span></span><span style=display:flex><span>     (<span style=color:#66d9ef>if</span> e1 e2 e3)]))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define-syntax</span> my-delay
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>syntax-rules</span> ()
</span></span><span style=display:flex><span>    [(my-delay e)
</span></span><span style=display:flex><span>     (mcons <span style=color:#66d9ef>#f</span> (<span style=color:#66d9ef>lambda</span> () e))]))
</span></span></code></pre></div><h3 id=hygiene>Hygiene</h3><h2 id=recursive-datatypes-via-racketss-struct>Recursive Datatypes Via Rackets&rsquo;s <code>struct</code></h2><p><a href="https://docs.racket-lang.org/reference/define-struct.html?q=struct#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29">https://docs.racket-lang.org/reference/define-struct.html?q=struct#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-racket data-lang=racket><span style=display:flex><span>(<span style=color:#66d9ef>struct</span> foo (bar baz quux) <span style=color:#66d9ef>#:transparent</span>
</span></span></code></pre></div></content><p><a href=https://damotek.github.io/www/blog/racket/>#racket</a></p></main><footer>Made with <a href=https://github.com/janraasch/hugo-bearblog/>Hugo ʕ•ᴥ•ʔ Bear</a></footer></body></html>